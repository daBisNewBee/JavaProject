package shotEveryDay.lock;

public class LockConcept {

    public static void main(String[] args) {
        /*
        *
        * Java 常见的锁分类及其特点相关题目解析：
        * https://mp.weixin.qq.com/s?__biz=MzI3ODc3NzQ4NQ==&mid=2247484364&idx=1&sn=e2b4df355d42a2a74495276a4272fb39&chksm=eb50982edc27113845ab8aa14b4c22b81234ddcd7e7c6ce1b387fa65a19b4d88796285497832&scene=21#wechat_redirect
        *
        * 引用：https://www.cnblogs.com/baizhanshi/p/6419268.html
        *
        * 1. 可重入锁
        *
        * （表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配）
        *
        * 是什么？ 比如同一个线程下，在method1中调用了method2，不用重新申请锁
        *
        * 好处？ 可重入锁可以在一定程度避免死锁。
        *
        * 举例？ synchronized和Lock都具备可重入性
        *
        * 存在不可重入锁（自旋锁）。
        *
        * */


        /*
        * 2.可中断锁
        *
        * synchronized就不是可中断锁，而Lock(lockInterruptibly())是可中断锁。
        *
        * */

        /*
        * 3.公平锁
        *
        * 公平指的是：是否按照线程的等待时间，来获得锁。（最先请求的线程优先获得锁）
        *
        * 非公平锁的缺点：即无法保证锁的获取是按照请求锁的顺序进行的。
        *               这样就可能导致某个或者一些线程永远获取不到锁。
        *
        * synchronized就是非公平锁；
        *
        * ReentrantLock(使用 CAS 和 AQS 实现)和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。
        *
        * */

        /*
        * 4.读写锁
        *
        * 细分了锁的粒度，主要在多个读操作时，提高效率。
        *
        * ReadWriteLock就是读写锁
        *
        * /

        /*
        * 5. 独享锁、共享锁
        *
        * 独享锁是指该锁一次只能被一个线程持有，共享锁指该锁可以被多个线程持有；
        *
        * synchronized 和 ReentrantLock 都是独享锁，
        *
        * ReadWriteLock 的读锁是共享锁，写锁是独占锁；
        *
        * ReentrantLock 的独享锁和共享锁也是通过 AQS 来实现的。
        *
        * */

        /*
        * 其他锁：
        *
        * 乐观锁、悲观锁：这个分类不是具体锁的分类，而是看待并发同步的角度；悲观锁认为对于同一个数
        *               据的并发操作一定是会发生修改的（哪怕实质没修改也认为会修改），因此对于同
        *               一个数据的并发操作悲观锁采取加锁的形式，因为悲观锁认为不加锁的操作一定有
        *               问题；乐观锁则认为对于同一个数据的并发操作是不会发生修改的，在更新数据的
        *               时候会采用不断的尝试更新，乐观锁认为不加锁的并发操作是没事的；由此可以看
        *               出悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带
        *               来大量的性能提升，悲观锁在 java 中很常见，乐观锁其实就是基于 CAS 的无锁
        *               编程，譬如 java 的原子类就是通过 CAS 自旋实现的。

          分段锁：实质是一种锁的设计策略，不是具体的锁，对于 ConcurrentHashMap 而言其并发的实现
                 就是通过分段锁的形式来实现高效并发操作；当要 put 元素时并不是对整个 hashmap 加锁，
                 而是先通过 hashcode 知道它要放在哪个分段，然后对分段进行加锁，所以多线程 put 元素
                 时只要放在的不是同一个分段就做到了真正的并行插入，但是统计 size 时就需要获取所有的
                 分段锁才能统计；分段锁的设计是为了细化锁的粒度。

          偏向锁、轻量级锁、重量级锁：这种分类是按照锁状态来归纳的，并且是针对 synchronized 的，
                 java 1.6 为了减少获取锁和释放锁带来的性能问题而引入的一种状态，其状态会随着竞
                 争情况逐渐升级，锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后无法降为偏向锁，
                 这种升级无法降级的策略目的就是为了提高获得锁和释放锁的效率。

          自旋锁：其实是相对于互斥锁的概念，互斥锁线程会进入 WAITING 状态和 RUNNABLE 状态的切换，
                 涉及上下文切换、cpu 抢占等开销，自旋锁的线程一直是 RUNNABLE 状态的，一直在那循
                 环检测锁标志位，机制不重复，但是自旋锁加锁全程消耗 cpu，起始开销虽然低于互斥锁，
                 但随着持锁时间加锁开销是线性增长。
                 应用：在多CPU的环境中，对持有锁较短的程序来说，使用自旋锁代替一般的互斥锁往往能够提高程序的性能。
                 因此自旋锁和互斥锁适用于不同的场景。自旋锁适用于那些仅需要阻塞很短时间的场景，而互斥锁适用于那些可能会阻塞很长时间的场景。
        *
        * */

    }

    public synchronized void method1() {
        method2();
    }

    public synchronized void method2() {

    }
}
